<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <title>Retro FPS Prototype</title>
  <style>
    body {
        margin: 0;
        overflow: hidden;
        background: #000;
        display: flex;
        justify-content: center;
        align-items: center;
        height: 100vh;
        width: 100vw;
      }
    
      canvas {
        max-width: 100%;
        max-height: 100%;
        object-fit: contain;
        image-rendering: pixelated;
        image-rendering: crisp-edges;
      }
    
      #instructions {
        position: absolute;
        top: 10px;
        left: 10px;
        color: white;
        font-family: sans-serif;
        pointer-events: none;
        z-index: 10;
      }
  </style>
</head>

<body>
  <div id="instructions">WASD to Move | Mouse to Look (Click screen)</div>
  <!-- Hidden image for texture atlas -->
  <img id="wallAtlas" style="display:none;" src="atlas.png">

  <script type="importmap" crossorigin="anonymous">
    {
      "imports": {
        "three": "https://unpkg.com/three@0.160.0/build/three.module.js"
      }
    }
  </script>
  <script type="module">
    import * as THREE from 'three';

    // 1. RETRO RENDERER SETUP
    const gameWidth = 320;
    const gameHeight = 240;

    const scene = new THREE.Scene();
    // Wolfenstein used a very wide FOV
    const camera = new THREE.PerspectiveCamera(75, gameWidth / gameHeight, 0.1, 100);
    camera.rotation.order = 'YXZ';

    // 1. HUD Scene & Orthographic Camera (Perfect for 2D)
    // const hudScene = new THREE.Scene();
    // const hudCamera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0.1, 10);
    // hudCamera.position.z = 1;

    // 2. The Gun Sprite
    const gunTexture = new THREE.TextureLoader().load('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAICAYAAADED76LAAAAIElEQVQYV2P8z8D/HwyAsJmBEZ8ChBaG0uByYAn0m4gXAD98D/G90X9eAAAAAElFTkSuQmCC');
    gunTexture.magFilter = THREE.NearestFilter;

    //    const gunMat = new THREE.SpriteMaterial({ map: gunTexture });
    //    const gunSprite = new THREE.Sprite(gunMat);
    //
    //    // Scale it and pin it to the bottom-center
    //    gunSprite.scale.set(0.5, 0.5, 1);
    //    gunSprite.position.set(0, -0.7, 0); // Bottom of screen
    //    hudScene.add(gunSprite);
    //    
    // 1. HUD Camera with very wide clipping planes (Near: -10, Far: 10)
    const hudCamera = new THREE.OrthographicCamera(-1, 1, 1, -1, -10, 10);
    const hudScene = new THREE.Scene();

    // 2. Create the Material
    // If your data URL is broken, this Color will at least show a red square
    const gunMat = new THREE.SpriteMaterial({
      map: gunTexture,
      color: 0xffffff, // Tint white (shows texture as-is)
      depthTest: false,
      depthWrite: false
    });

    const gunSprite = new THREE.Sprite(gunMat);

    // 3. Position: (0, 0, 0) is dead center. 
    // Let's put it at (0, 0, 0) first to make sure you see it.
    gunSprite.scale.set(0.5, 0.5, 1);
    gunSprite.position.set(0, 0, 0);

    hudScene.add(gunSprite);

    const renderer = new THREE.WebGLRenderer({ antialias: false });
    renderer.setSize(gameWidth, gameHeight, false); // False means "don't set CSS size"

    // Style the canvas for that "chunky" upscale
    renderer.domElement.style.width = '100vw';
    renderer.domElement.style.height = '100vh';
    renderer.domElement.style.imageRendering = 'pixelated';
    renderer.domElement.style.imageRendering = 'crisp-edges';
    document.body.appendChild(renderer.domElement);

    // Request pointer lock when the user clicks the canvas
    renderer.domElement.addEventListener('click', () => {
      renderer.domElement.requestPointerLock();
    });

    // 2. TEXTURE-LESS RETRO LOOK
    // We use a dark fog to hide the edges of the map
    scene.fog = new THREE.Fog(0x000000, 1, 8);

    const map = [
      [1, 4, 1, 4, 1, 4, 1, 4],
      [4, 0, 0, 0, 0, 0, 0, 1],
      [1, 0, 2, 2, 0, 3, 0, 4],
      [4, 0, 0, 0, 0, 0, 0, 1],
      [1, 0, 0, 0, 5, 0, 0, 4],
      [4, 0, 1, 1, 1, 0, 0, 1],
      [1, 0, 0, 0, 0, 0, 0, 1],
      [1, 1, 1, 1, 1, 1, 1, 1],
    ];

    const wallGeo = new THREE.BoxGeometry(1, 1, 1);
    
    // Load texture atlas from file
    const wallImg = document.getElementById('wallAtlas');
    const wallTexture = new THREE.Texture(wallImg);
    // If the image is already loaded, trigger update immediately
    if (wallImg.complete) wallTexture.needsUpdate = true;
    else wallImg.onload = () => { wallTexture.needsUpdate = true; };

    wallTexture.magFilter = THREE.NearestFilter;

    const wallMat = new THREE.MeshLambertMaterial({ map: wallTexture });

    map.forEach((row, z) => {
      row.forEach((cell, x) => {
        if (cell > 0) {
          // Clone geometry so we can modify UVs per-wall
          const geo = wallGeo.clone();
          const uvAttribute = geo.attributes.uv;
          
          // Example: 2x2 Atlas. cell 1 = top-left, cell 2 = top-right
          const atlasSize = 8; 
          const u = ((cell - 1) % atlasSize) / atlasSize;
          const v = 1 - (Math.floor((cell - 1) / atlasSize) + 1) / atlasSize;

          for (let i = 0; i < uvAttribute.count; i++) {
            let xUv = uvAttribute.getX(i);
            let yUv = uvAttribute.getY(i);
            uvAttribute.setXY(i, u + xUv / atlasSize, v + yUv / atlasSize);
          }

          const wall = new THREE.Mesh(geo, wallMat);
          wall.position.set(x, 0.5, z);
          scene.add(wall);
        }
      });
    });

    // Floor and Ceiling (Standard in Wolfenstein)
    const planeGeo = new THREE.PlaneGeometry(20, 20);

    // Helper to crop a texture from the atlas so it can repeat
    const createCroppedTexture = (img, tileIndex, atlasSize) => {
      const canvas = document.createElement('canvas');
      const ctx = canvas.getContext('2d');
      const tex = new THREE.CanvasTexture(canvas);
      tex.magFilter = THREE.NearestFilter;
      tex.minFilter = THREE.NearestFilter;
      tex.wrapS = THREE.RepeatWrapping;
      tex.wrapT = THREE.RepeatWrapping;

      const update = () => {
        const tileSize = img.width / atlasSize;
        canvas.width = tileSize;
        canvas.height = tileSize;
        const col = tileIndex % atlasSize;
        const row = Math.floor(tileIndex / atlasSize);
        ctx.drawImage(img, col * tileSize, row * tileSize, tileSize, tileSize, 0, 0, tileSize, tileSize);
        tex.needsUpdate = true;
      };

      if (img.complete && img.width > 0) update();
      else img.addEventListener('load', update);

      return tex;
    };

    const mapSize = map.length;
    const mapCenter = (mapSize - 1) / 2;

    const floorTexture = createCroppedTexture(wallImg, 62, 8);
    const floorMat = new THREE.MeshLambertMaterial({ map: floorTexture });
    floorTexture.repeat.set(20, 20);

    const floor = new THREE.Mesh(planeGeo, floorMat);
    floor.rotation.x = -Math.PI / 2;
    floor.position.set(mapCenter, 0, mapCenter);
    scene.add(floor);

    const ceilTexture = createCroppedTexture(wallImg, 63, 8);
    const ceilMat = new THREE.MeshLambertMaterial({ map: ceilTexture });
    ceilTexture.repeat.set(20, 20);

    const ceil = new THREE.Mesh(planeGeo, ceilMat);
    ceil.rotation.x = Math.PI / 2;
    ceil.position.set(mapCenter, 1, mapCenter);
    scene.add(ceil);

    const light = new THREE.PointLight(0xffffff, 1, 7);
    scene.add(light, new THREE.AmbientLight(0xaaaaaa, 2));

    // 3. MOVEMENT ENGINE
    const keys = {};
    const player = { pos: new THREE.Vector3(1.5, 0.5, 1.5), rot: 0, speed: 0.06 };

    window.addEventListener('keydown', (e) => keys[e.code] = true);
    window.addEventListener('keyup', (e) => keys[e.code] = false);

    // Mouse look handler
    document.addEventListener('mousemove', (event) => {
      // Only rotate camera if pointer is locked
      if (document.pointerLockElement === renderer.domElement) {
        // Horizontal look (around Y axis)
        player.rot -= event.movementX * 0.002;
        // Vertical look (around X axis) - apply to camera directly
        camera.rotation.x -= event.movementY * 0.002;
        // Clamp vertical rotation to prevent flipping
        camera.rotation.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, camera.rotation.x));
      }
    });

    function checkCollision(x, z) {
      return map[Math.round(z)]?.[Math.round(x)] > 0;
    }

    function animate() {
      requestAnimationFrame(animate);
      
      let dx = 0, dz = 0;
      if (keys['KeyW']) { dx += -Math.sin(player.rot) * player.speed; dz += -Math.cos(player.rot) * player.speed; }
      if (keys['KeyS']) { dx += Math.sin(player.rot) * player.speed; dz += Math.cos(player.rot) * player.speed; }
      if (keys['KeyA']) { dx += -Math.cos(player.rot) * player.speed; dz += Math.sin(player.rot) * player.speed; }
      if (keys['KeyD']) { dx += Math.cos(player.rot) * player.speed; dz += -Math.sin(player.rot) * player.speed; }

      // Collision with 0.2 radius buffer
      if (!checkCollision(player.pos.x + dx + (dx > 0 ? 0.2 : -0.2), player.pos.z)) player.pos.x += dx;
      if (!checkCollision(player.pos.x, player.pos.z + dz + (dz > 0 ? 0.2 : -0.2))) player.pos.z += dz;

      camera.position.set(player.pos.x, 0.5, player.pos.z);
      camera.rotation.y = player.rot;

      // Light stays with the player (like a lantern)
      light.position.copy(camera.position);

      // Render Pass 1: The 3D World
      renderer.autoClear = true; // Clear the previous frame
      renderer.render(scene, camera);

      // Render Pass 2: The 2D HUD
      renderer.autoClear = false; // DON'T clear the 3D world we just drew
      renderer.clearDepth();      // Just clear the depth buffer so the gun is "on top"
      renderer.render(hudScene, hudCamera);
    }
    animate();


  </script>
</body>

</html>
